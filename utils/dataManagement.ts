import { goalTable, shortGoalTable, streakHistoryTable, userStatsTable } from '@/db/schema';
import { drizzle } from 'drizzle-orm/expo-sqlite';
import * as Application from 'expo-application';
import * as Crypto from 'expo-crypto';
import * as DocumentPicker from 'expo-document-picker';
import * as FileSystem from 'expo-file-system/legacy';
import * as Sharing from 'expo-sharing';
import { useSQLiteContext } from 'expo-sqlite';
import { Alert, Platform } from 'react-native';

// Define the shape of our export data
interface ExportData {
  metadata: {
    appName: string;
    bundleId: string | null;
    platform: string;
    version: number;
    timestamp: string;
  };
  data: {
    goals: any[];
    shortGoals: any[];
    userStats: any[];
    streakHistory: any[];
  };
  checksum: string;
}

const EXPORT_VERSION = 1;
const APP_NAME_ID = "LittleProgress"; // Internal ID for verification

export const useDataManagement = () => {
  const db = useSQLiteContext();
  const drizzleDb = drizzle(db);

  const exportData = async () => {
    try {
      // 1. Fetch all data
      const goals = await drizzleDb.select().from(goalTable).all();
      const shortGoals = await drizzleDb.select().from(shortGoalTable).all();
      const userStats = await drizzleDb.select().from(userStatsTable).all();
      const streakHistory = await drizzleDb.select().from(streakHistoryTable).all();

      const dataPayload = {
        goals,
        shortGoals,
        userStats,
        streakHistory,
      };

      // 2. Calculate Checksum (SHA-256)
      const jsonPayload = JSON.stringify(dataPayload);
      const checksum = await Crypto.digestStringAsync(
        Crypto.CryptoDigestAlgorithm.SHA256,
        jsonPayload
      );

      // 3. Prepare Final JSON
      const exportObject: ExportData = {
        metadata: {
          appName: APP_NAME_ID,
          bundleId: Application.applicationId,
          platform: Platform.OS,
          version: EXPORT_VERSION,
          timestamp: new Date().toISOString(),
        },
        data: dataPayload,
        checksum,
      };

      const jsonString = JSON.stringify(exportObject, null, 2);
      const fileName = `littleprogress_backup_${new Date().toISOString().split('T')[0]}.json`;
      const filePath = `${FileSystem.documentDirectory}${fileName}`;

      // 4. Write to file
      await FileSystem.writeAsStringAsync(filePath, jsonString);

      // 5. Share file
      if (await Sharing.isAvailableAsync()) {
        await Sharing.shareAsync(filePath, {
          mimeType: 'application/json',
          dialogTitle: 'Export Data',
          UTI: 'public.json', // for iOS
        });
      } else {
        Alert.alert("Error", "Sharing is not available on this device");
      }
    } catch (error) {
      console.error("Export failed:", error);
      Alert.alert("Export Failed", "An error occurred while exporting your data.");
    }
  };

  const importData = async () => {
    try {
      // 1. Pick file
      const result = await DocumentPicker.getDocumentAsync({
        type: ['application/json', 'public.json'],
        copyToCacheDirectory: true,
      });

      if (result.canceled) return;

      const fileUri = result.assets[0].uri;
      const fileContent = await FileSystem.readAsStringAsync(fileUri);
      
      let exportObject: ExportData;
      try {
        exportObject = JSON.parse(fileContent);
      } catch (e) {
        Alert.alert("Invalid File", "The selected file is not a valid JSON.");
        return;
      }

      // 2. Verify Metadata (App ID)
      if (exportObject.metadata?.appName !== APP_NAME_ID) {
        Alert.alert("Invalid Backup", "This file was not generated by LittleProgress.");
        return;
      }

      // 3. Verify Integrity (Checksum)
      const jsonPayload = JSON.stringify(exportObject.data);
      const calculatedChecksum = await Crypto.digestStringAsync(
        Crypto.CryptoDigestAlgorithm.SHA256,
        jsonPayload
      );

      if (calculatedChecksum !== exportObject.checksum) {
        Alert.alert("Data Corrupted", "The backup file appears to be modified or corrupted.");
        return;
      }

      // 4. Validate Data Structure
      if (!exportObject.data.goals || !exportObject.data.shortGoals || !exportObject.data.userStats || !exportObject.data.streakHistory) {
        Alert.alert("Invalid Data", "Missing required data fields.");
        return;
      }

      // 5. Confirm overwrite
      Alert.alert(
        "Confirm Import",
        "This will overwrite your current data. This action cannot be undone. Are you sure?",
        [
          { text: "Cancel", style: "cancel" },
          {
            text: "Import & Overwrite",
            style: "destructive",
            onPress: async () => {
              await performImport(exportObject.data);
            },
          },
        ]
      );

    } catch (error) {
      console.error("Import failed:", error);
      Alert.alert("Import Failed", "An error occurred while importing your data.");
    }
  };

  const performImport = async (data: ExportData['data']) => {
    try {
      // 1. Clear existing tables
      await drizzleDb.delete(goalTable).run();
      await drizzleDb.delete(shortGoalTable).run();
      await drizzleDb.delete(userStatsTable).run();
      await drizzleDb.delete(streakHistoryTable).run();

      // 2. Insert new data
      if (data.goals.length > 0) {
        await drizzleDb.insert(goalTable).values(data.goals).run();
      }
      if (data.shortGoals.length > 0) {
        await drizzleDb.insert(shortGoalTable).values(data.shortGoals).run();
      }
      if (data.userStats.length > 0) {
        await drizzleDb.insert(userStatsTable).values(data.userStats).run();
      }
      if (data.streakHistory.length > 0) {
        await drizzleDb.insert(streakHistoryTable).values(data.streakHistory).run();
      }

      Alert.alert("Success", "Data imported successfully! Please restart the app to see changes.");
      
    } catch (error) {
      console.error("Import transaction failed:", error);
      Alert.alert("Import Error", "Failed to restore data. Your previous data might be partially deleted.");
    }
  };

  return { exportData, importData };
};
